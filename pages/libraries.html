---
# jekyll header
---

{% include header.html %}

<!-- ============BreadCrumb=============== -->

{% include container-start.html %}

<!-- ============CONTENT CONTENT=============== -->

<a name="libraries"> </a>
<h2><span class="sectioncount">6.0.0</span> Libraries <a href="libraries.html#libraries" title="link to here" class="self-link"><img src="target.png" width="20" class="self-link" height="20"/></a></h2>
<p>&nbsp;</p>

<p>This implementation guide uses the Library resource to represent libraries of computable content (such as Clinical Quality Language libraries). The guidance here builds on the <a href="http://hl7.org/fhir/R4/clinicalreasoning-knowledge-artifact-representation.html#library">Library</a> topic, providing additional guidance on the use of libraries within computable guidelines.</p>

<h3 id="using-cql">Using CQL</h3>

<h4 id="cql-libraries">CQL Libraries</h4>

<p>Any CQL library referenced by a computable artifact SHALL contain a library declaration line as the first line of the library.</p>

<p>The library identifier SHALL be a valid un-quoted identifier and SHALL NOT contain underscores</p>

<p>The library declaration line SHALL contain a version number.</p>

<p>The library version number SHALL follow the convention: <code class="highlighter-rouge">&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code></p>

<h5 id="library-versioning">Library Versioning</h5>

<p>This implementation guide uses an approach to versioning libraries used within computable guidelines to help track and manage dependencies. The approach used here is based on the <a href="https://apr.apache.org/versioning.html">Apache APR Versioning Scheme</a>.</p>

<p>There are three main types of changes that can be made to a library:</p>

<ol>
  <li><strong>Major</strong>: A change that alters the public use of the components of a library</li>
  <li><strong>Minor</strong>: A change that adds new components or functionality but does not change existing components.</li>
  <li><strong>Patch</strong>: A change that does not impact the public use of the library, but only corrects or improves the originally intended functionality.</li>
</ol>

<p>By exposing version numbers that identify all three types of changes, libraries can be versioned in a way that makes clear when a change will impact usage, versus when a change can potentially be safely incorporated as an update.</p>

<p>Content conforming to this implementation guide SHALL increment major, minor, and patch version numbers for the CQL consistent with the types of changes made to the content.</p>

<p>For example:</p>

<pre><code class="language-cql">library EXM146 version '1.0.0'
</code></pre>

<p>This would indicate the first major version of the EXM146 library. A minor change could be released by incrementing the minor version:</p>

<pre><code class="language-cql">library EXM146 version '1.1.0'
</code></pre>

<p>And a major change could be released by incrementing the major version, and resetting the minor version: Minor changes are expected to retain backwards-compatibility, but may introduce new features and functionality, while patch changes are expected to retain forward and backwards-compatibility, and may only be used to fix issues.</p>

<h5 id="nested-libraries">Nested Libraries</h5>

<p>CQL allows libraries to re-use logic already defined in other libraries. This is accomplished by utilizing the <code class="highlighter-rouge">include</code> declaration:</p>

<pre><code class="language-cql">include CommonFHIR version '2.0.0' called Common
</code></pre>

<p>The set of all CQL libraries used from any given computable artifact SHALL be structured such that all references to CQL components from a given resource are included in a single library.</p>

<p>Because of this conformance statement, resources that reference CQL expression definitions only need to reference a single <em>primary library</em>, eliminating the need to qualify expression definitions from references in the resource.</p>

<h5 id="library-namespaces">Library Namespaces</h5>

<p>CQL allows libraries to define a namespace that can be used to organize libraries across different groups of authors. Within a namespace, library names are required to be unique. Across namespaces, the same library name may be reused. For example, OrganizationA and OrganizationB can both define a library named <code class="highlighter-rouge">Common</code>, so long as they use different namespaces. For example, consider the following library declaration:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library CMS.Common version '2.0.0'
</code></pre></div></div>

<p>This example declares a library named Common in the CMS namespace. Per the CQL specification, the namespace for a library is included in the ELM, along with a URI that provides a globally unique, stable identifier for the namespace. As an example, the URI for the CMS namespace might be <code class="highlighter-rouge">http://ecqi.healthit.gov/ecqm/measures</code>.</p>

<p>Although the URI for a CQL namespace SHOULD correspond to a reachable web address (i.e. a URL), this is not required. However, global uniqueness of the namespace URI is required in order to avoid namespace clashes.</p>

<h4 id="data-model">Data Model</h4>

<p>CQL can be used with any data model. In the context of a given computable artifact, any referenced CQL library SHALL identify the data model with a <code class="highlighter-rouge">using</code> declaration that includes a version specifier.</p>

<p>All CQL expressions used directly or indirectly within an artifact SHALL reference a single data model, with the exception that the <code class="highlighter-rouge">System</code> model is always implicitly referenced.</p>

<p>For example:</p>

<pre><code class="language-cql">using FHIR version '4.0.0'
</code></pre>

<h4 id="code-systems">Code Systems</h4>

<p>Within CQL, the identifier of any code system reference SHALL be specified using a URI for the code system.</p>

<p>The URI SHALL be the canonical URL for the code system as defined by either the base FHIR specification or the referenced <code class="highlighter-rouge">CodeSystem</code> resource.</p>

<p>The URI MAY include a version, consistent with the URI specification for FHIR and the code system</p>

<p>For example:</p>

<pre><code class="language-cql">codesystem "SNOMEDCT:2017-09": 'http://snomed.info/sct'
  version 'http://snomed.info/sct/731000124108/version/201709'
</code></pre>

<p>The canonical URL for a code system is a globally unique, stable, version-independent identifier for the code system. The base FHIR specification defines canonical URLs for most common code systems <a href="http://hl7.org/fhir/R4/terminologies-systems.html">here</a>.</p>

<p>The local identifier for the codesystem (“SNOMED-CT” in this case) SHOULD include the friendly name of the code system and MAY include an indication of the version, separated with a colon.</p>

<p>Version information for code systems is not required to be included in computable guideline CQL; terminology versioning information may be specified externally. However, if versioning information is included, it must be done in accordance with the terminology usage specified by FHIR.</p>

<h4 id="value-sets">Value Sets</h4>

<p>Value sets are used to provide a level of indirection between the concepts you’re referencing in the logic and the way those concepts are specifically defined. By using a value set, you can define that concept in terms of different code systems, and it has the added benefit of providing a sort of “configuration point” for local implementation to map local concepts.</p>

<p>When using value sets, authors can either find value sets that are already defined (in the VSAC, or elsewhere), or construct value sets themselves. When constructing value sets, care should be taken not to create duplicate value sets (i.e. value sets with the same purpose and definition). When using published value sets, care must be taken to ensure that they are both actively stewarded (i.e. kept up to date in the published repository) and actively maintained when used in production settings.</p>

<p>When using value set declarations, authors should use the name of the value set as defined externally to avoid introducing any potential confusion of meaning. One exception to this is when different value sets are defined with the same name in an external repository, then some additional aspect is required to ensure uniqueness of the names within the CQL library.</p>

<p>Within CQL, the identifier of any value set reference SHALL be specified using a URI for the value set.</p>

<p>The URI SHALL be the canonical URL for the value set as defined by either the base FHIR specification or the referenced <code class="highlighter-rouge">ValueSet</code> resource.</p>

<p>The URI MAY include a version, consistent with versioned canonical URL references in FHIR</p>

<p>For example:</p>

<pre><code class="language-cql">valueset "Acute Pharyngitis": 'valueset "Acute Pharyngitis": 'http://cts.nlm.nih.gov/fhir/ValueSet/2.16.840.1.113883.3.464.1003.102.12.1011'
</code></pre>

<p>The canonical URL for a value set is typically defined by the value set author, though it may be provided by the publisher as well. For example, value sets defined in the Value Set Authority Center and exposed via the VSAC FHIR interface have a base URL of <code class="highlighter-rouge">http://cts.nlm.nih.gov/fhir/</code>. This base is then used to construct the canonical URL for the value set (in the same way as any FHIR URL) using the resource type (<code class="highlighter-rouge">ValueSet</code> in this case) and the id (the value set OID in this case).</p>

<p>The local identifier for the value set within CQL should be the same as the name of the published value set. However, because the name of the value set is not guaranteed to be unique, it is possible to reference multiple value sets with the same name, but different identifiers. When this happens in a CQL library, the local identifier should be the name of the value set with a qualifying suffix to preserve the value set name as a human-readable artifact, but still allow unique reference within the CQL library.</p>

<p>For example:</p>

<pre><code class="language-cql">valueset "Acute Pharyngitis (1)": 'http://cts.nlm.nih.gov/fhir/ValueSet/2.16.840.1.113883.3.464.1003.102.12.1011.1'
valueset "Acute Pharyngitis (2)": 'http://cts.nlm.nih.gov/fhir/ValueSet/2.16.840.1.113883.3.464.1003.102.12.1011.2'
</code></pre>

<p>Version information for value sets is not required to be included in computable guideline CQL; terminology versioning information may be specified externally. However, if versioning information is included, it must be done in accordance with the terminology usage specified by FHIR.</p>

<h5 id="value-set-version">Value Set Version</h5>

<p>When retrieving the expansion of a value set by version, the version indicator SHALL be appended to the canonical URL for the value set, separated by a pipe (<code class="highlighter-rouge">|</code>)</p>

<p>For example:</p>

<pre><code class="language-cql">valueset "Encounter Inpatient SNOMEDCT Value Set":
   'http://cts.nlm.nih.gov/fhir/ValueSet/2.16.840.1.113883.3.666.7.307|20160929'
</code></pre>

<h4 id="codes">Codes</h4>

<p>When direct reference codes are represented within CQL, the logical identifier SHALL NOT be a URI and SHALL be a code from the referenced code system.</p>

<p>Using “direct-reference codes”, involves declaring an identifier for a specific code in a code system, and using that directly within the logic. That’s appropriate for cases where you know exactly what you want, and there’s very little possibility for variation on that (i.e. systems are likely to use those codes directly, rather than have local codes that they are mapping to).</p>

<p>When using direct reference codes, authors should use the name of the code as defined externally to avoid introducing any potential confusion of meaning:</p>

<pre><code class="language-cql">code "Venous foot pump, device (physical object)": '442023007' from "SNOMED-CT"
</code></pre>

<p>Note that for direct reference code usage, the local identifier (in the example above, the local identifier is <code class="highlighter-rouge">"Venous foot pump, device (physical object)"</code>) should be the same as the description of the code within the terminology in order to avoid conflicting with any usage or license agreements with the referenced terminologies, but can be different to allow for potential naming conflicts, as well as simplification of longer names when appropriate.</p>

<p>Although CQL supports both version-specific and version-independent specification of and comparison to direct reference codes, artifact authors should use version-independent direct reference codes and comparisons unless there is a specific reason not to (such as the code is retired in the current code system version). Even when using version-specific direct reference codes, authors should use equivalence (<code class="highlighter-rouge">~</code>) for the comparison (again, unless there is a specific reason to use version-specific comparison with equality (<code class="highlighter-rouge">=</code>)).</p>

<p>Note: Using direct-reference codes can be more difficult for implementations to map to local settings, because modification of the codes for local usage may require modification of the CQL, as opposed to the use of a value set which many systems already use to provide support for mapping to local codes.</p>

<h4 id="library-level-identifiers">Library-level Identifiers</h4>

<p>A <em>library-level identifier</em> is any named expression, function, parameter, code system, value set, concept, or code defined in the CQL. The library name referenced in the library-line, the data model, and any referenced external library should not be considered library-level identifiers. Library-level identifiers should be given a descriptive and meaningful name (avoid abbreviations) and conform to the following requirements:</p>

<p>Library-level identifiers:</p>
<ul>
  <li>SHOULD use quoted identifiers,</li>
  <li>SHOULD Use Title Case, and</li>
  <li>MAY Include spaces.</li>
</ul>

<p>For example:</p>

<pre><code class="language-cql">define function
    "Includes Or Starts During"(Diagnosis "Diagnosis", Encounter "Encounter, Performed"):
        Diagnosis.prevalencePeriod includes Encounter.relevantPeriod
            or Diagnosis.prevalencePeriod starts during Encounter.relevantPeriod
</code></pre>

<h4 id="data-type-names">Data Type Names</h4>

<p>Data type names referenced in CQL SHALL use quoted identifiers and SHOULD use PascalCase.</p>

<h4 id="negation-in-fhir">Negation in FHIR</h4>

<p>Two commonly used patterns for negation in quality improvement are:</p>

<ul>
  <li>Absence of evidence for a particular event</li>
  <li>Documentation of an event not occurring, together with a reason</li>
</ul>

<p>For the purposes of quality improvement, when looking for documentation that a particular event did not occur, it must be documented with a reason in order to meet the intent. If a reason is not part of the intent, then the absence of evidence pattern should be used, rather than documentation of an event not occurring.</p>

<p>To address the reason an action did not occur (negation rationale), the computable artifact must define the event it expects to occur using appropriate terminology to identify the kind of event (using a value set or direct reference code), and then use additional criteria to indicate that the event did not occur, as well as identifying a reason.</p>

<p>The following examples differentiate methods to indicate (a) presence of evidence of an action, (b) absence of evidence of an action, and (c) negation rationale for not performing an action. In each case, the “action” is an administration of medication included within a value set for “Antithrombotic Therapy”.</p>

<h5 id="presence">Presence</h5>

<p>Evidence that “Antithrombotic Therapy” (defined by a medication-specific value set) was administered:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>define "Antithrombotic Administered":
  ["MedicationAdministration": "Antithrombotic Therapy"] AntithromboticTherapy
    where AntithromboticTherapy.status = 'completed'
      and AntithromboticTherapy.category = "Inpatient Setting"
</code></pre></div></div>

<h5 id="absence">Absence</h5>

<p>No evidence that “Antithrombotic Therapy” medication was administered:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>define "No Antithrombotic Therapy":
  not exists (
    ["MedicationAdministration": "Antithrombotic Therapy"] AntithromboticTherapy
      where AntithromboticTherapy.status = 'completed'
        and AntithromboticTherapy.category = "Inpatient Setting"
  )
</code></pre></div></div>

<h5 id="negation-rationale">Negation Rationale</h5>

<p>Evidence that “Antithrombotic Therapy” medication administration did not occur for an acceptable medical reason as defined by a value set referenced by the computable artifact (i.e., negation rationale):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>define "Antithrombotic Not Administered":
  ["MedicationAdministration": "Antithrombotic Therapy"] NotAdministered
    where NotAdministered.notGiven is true
      and NotAdministered.reasonNotGiven in "Medical Reason"
</code></pre></div></div>

<p>In this example for negation rationale, the logic looks for a member of the value set “Medical Reason” as the rationale for not administering the medication. However, underlying systems might not represent the negated action with a code from the “Antithrombotic Therapy” value set. When justifying the reason for not administering a particular medication, clinicians do not generally select a specific medication, they most often indicate avoidance of a set of medications, typically defined by a value set used in a quality improvement artifact (such as a quality measure or a decision support rule). In these cases, the value set may be used as a placeholder to indicate that no medications from the given value set were administered. Implementations processing data reported in this way should take into account that the reported data may not be returned with a single code, but rather a value set identifier, and should consider data with the appropriate value set identifier as satisfying the criteria for value set membership.</p>

<p>Similarly, representing that a procedure for Cardiac Surgery was not performed should not require specification of which cardiac surgery in a value set was not performed, but only a reference to the value set defining the set of possible procedures that are expected to have been performed. The same process works for any application of negation rationale.</p>

<p>Within FHIR, the <a href="http://hl7.org/fhir/R4/extension-valueset-reference.html">valueset-reference</a> extension can be used to indicate the defining value set for a negation.</p>

<h4 id="attribute-names">Attribute Names</h4>

<p>Data type attributes referenced from CQL SHOULD NOT use quoted identifiers and SHOULD use camelCase.</p>

<p>Examples of attributes conforming to this requirement are given below. Note however that the full list of valid attributes, is specified by the data model. For example, the following are valid attributes in FHIR:</p>

<pre><code class="language-cql">period
authoredOn
result
</code></pre>

<h4 id="aliases-and-argument-names">Aliases and Argument Names</h4>

<p>Aliases are used in CQL as local variable names to refer to sections of code. When defining a function, argument names are used to create scoped variables that refer to the function inputs.</p>

<p>Aliases and argument names referenced in the CQL:</p>
<ul>
  <li>SHOULD NOT use quoted identifiers,</li>
  <li>SHOULD use PascalCase,</li>
  <li>SHOULD use descriptive names (no abbreviations).</li>
</ul>

<p>For example:</p>

<pre><code class="language-cql">define "Encounters During Measurement Period":
    "Valid Encounters" QualifyingEncounter
        where QualifyingEncounter.period during "Measurement Period"

define function "ED Stay Time"(Encounter "Encounter, Performed"):
    duration in minutes of Encounter.period
</code></pre>

<h3 id="library-resources">Library Resources</h3>

<p>Inclusion of CQL content used within computable guideline artifacts is accomplished through the use of a Library resource. These libraries are then referenced from guideline artifacts using the <code class="highlighter-rouge">library</code> element. The content of the CQL library is included using the <code class="highlighter-rouge">content</code> element of the Library.</p>

<p>Content conforming to this implementation guide SHALL use at least the <a href="StructureDefinition-cpg-shareablelibrary.html">cpg-shareablelibrary</a> profile for Library resources.</p>

<h4 id="library-name-and-url">Library Name and URL</h4>

<p>The identifying elements of a library SHALL conform to the following requirements:</p>
<ul>
  <li>Library.url SHALL be <code class="highlighter-rouge">&lt;CQL namepsace url&gt;/Library/&lt;CQL library name&gt;</code></li>
  <li>Library.name SHALL be <code class="highlighter-rouge">&lt;CQL library name&gt;</code></li>
  <li>Library.version SHALL be <code class="highlighter-rouge">&lt;CQL library version&gt;</code></li>
</ul>

<p>For libraries included in FHIR implementation guides, the CQL namespace is defined by the implementation guide as follows:</p>
<ul>
  <li>CQL namespace name SHALL be IG.packageId</li>
  <li>CQL namespace url SHALL be IG.canonicalBase</li>
</ul>

<p>For CQL library source files, the convention SHOULD be:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filename = &lt;CQL library name&gt;.cql
</code></pre></div></div>

<p>To avoid issues with characters between web ids and names, library names SHALL NOT have underscores.</p>

<h4 id="fhir-type-mapping">FHIR Type Mapping</h4>

<p>CQL defined types map to types in FHIR according to the following mapping:</p>

<table>
  <thead>
    <tr>
      <th>CQL System Type</th>
      <th>FHIR Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">System.Boolean</code></td>
      <td><code class="highlighter-rouge">FHIR.boolean</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.Integer</code></td>
      <td><code class="highlighter-rouge">FHIR.integer</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.Decimal</code></td>
      <td><code class="highlighter-rouge">FHIR.decimal</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.Date</code></td>
      <td><code class="highlighter-rouge">FHIR.date</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.DateTime</code></td>
      <td><code class="highlighter-rouge">FHIR.dateTime</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.Time</code></td>
      <td><code class="highlighter-rouge">FHIR.time</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.String</code></td>
      <td><code class="highlighter-rouge">FHIR.string</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.Quantity</code></td>
      <td><code class="highlighter-rouge">FHIR.Quantity</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.Ratio</code></td>
      <td><code class="highlighter-rouge">FHIR.Ratio</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.Any</code></td>
      <td><code class="highlighter-rouge">FHIR.Any</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.Code</code></td>
      <td><code class="highlighter-rouge">FHIR.Coding</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">System.Concept</code></td>
      <td><code class="highlighter-rouge">FHIR.CodeableConcept</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Interval&lt;System.Date&gt;</code></td>
      <td><code class="highlighter-rouge">FHIR.Period</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Interval&lt;System.DateTime&gt;</code></td>
      <td><code class="highlighter-rouge">FHIR.Period</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Interval&lt;System.Quantity&gt;</code></td>
      <td><code class="highlighter-rouge">FHIR.Range</code></td>
    </tr>
  </tbody>
</table>

<p>In addition:</p>
<ul>
  <li>List types SHALL be lists of element types that map to FHIR</li>
  <li>Tuple types SHALL consist only of elements of types that map to FHIR</li>
</ul>

<h4 id="parameters-and-data-requirements">Parameters and Data Requirements</h4>

<p>Parameters to CQL libraries SHALL be either CQL-defined types that map to FHIR types, or FHIR resource types, optionally with profile designations.</p>

<p>Top level expressions in CQL libraries SHALL return either CQL-defined types that map to FHIR types, or FHIR resources types, optionally with profile designations</p>

<p>Libraries used in computable guideline content SHALL use the <code class="highlighter-rouge">dataRequirement</code> element to identify any retrieves present in the CQL:</p>

<table>
  <thead>
    <tr>
      <th>Retrieve Element</th>
      <th>DataRequirement Element</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>dataType</td>
      <td>type</td>
    </tr>
    <tr>
      <td>templateId</td>
      <td>profile</td>
    </tr>
    <tr>
      <td>context</td>
      <td>subject</td>
    </tr>
    <tr>
      <td>codeProperty</td>
      <td>codeFilter.path or codeFilter.searchParam</td>
    </tr>
    <tr>
      <td>codes (Concept)</td>
      <td>codeFilter.code (for each Code present in the Concept)</td>
    </tr>
    <tr>
      <td>codes (Code)</td>
      <td>codeFilter.code</td>
    </tr>
    <tr>
      <td>codes (ValueSetRef)</td>
      <td>codeFilter.valueSet (as specified by the <code class="highlighter-rouge">id</code> of the ValueSetDef referenced by the ValueSetRef)</td>
    </tr>
    <tr>
      <td>dateProperty</td>
      <td>dateFilter.path</td>
    </tr>
    <tr>
      <td>dateLowProperty,dateHighProperty</td>
      <td>dateFilter.path (resolved to an interval-valued property)</td>
    </tr>
    <tr>
      <td>dateRange</td>
      <td>dateFilter.path or dateFilter.searchParam</td>
    </tr>
  </tbody>
</table>

<h4 id="relatedartifacts">RelatedArtifacts</h4>

<p>Libraries used in computable guideline content SHALL use the <code class="highlighter-rouge">relatedArtifact</code> element to identify includes, code systems, value sets, and data models used by the CQL library:</p>

<table>
  <tbody>
    <tr>
      <td>Dependency</td>
      <td>RelatedArtifact representation</td>
    </tr>
    <tr>
      <td>Data Model (using declaration)</td>
      <td><code class="highlighter-rouge">depends-on</code> with <code class="highlighter-rouge">url</code> of the ModelInfo Library (e.g. <code class="highlighter-rouge">http://hl7.org/fhir/Library/FHIR-ModelInfo|4.0.1</code>)</td>
    </tr>
    <tr>
      <td>Library (include declaration)</td>
      <td><code class="highlighter-rouge">depends-on</code> with <code class="highlighter-rouge">url</code> of the Library (e.g. <code class="highlighter-rouge">http://hl7.org/fhir/Library/FHIRHelpers|4.0.1</code>)</td>
    </tr>
    <tr>
      <td>Code System</td>
      <td><code class="highlighter-rouge">depends-on</code> with <code class="highlighter-rouge">url</code> of the CodeSystem (e.g. <code class="highlighter-rouge">http://loing.org</code>)</td>
    </tr>
    <tr>
      <td>Value Set</td>
      <td><code class="highlighter-rouge">depends-on</code> with <code class="highlighter-rouge">url</code> of the ValueSet (e.g. <code class="highlighter-rouge">http://cts.nlm.nih.gov/fhir/ValueSet/2.16.840.1.113762.1.4.1116.89</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="using-terminology-in-cql-authoring">Using Terminology in CQL Authoring</h4>

<p>FHIR supports various types of terminology-valued elements, including:</p>

<ul>
  <li><a href="http://hl7.org/fhir/datatypes.html#code">code</a></li>
  <li><a href="http://hl7.org/fhir/datatypes.html#Coding">Coding</a></li>
  <li><a href="http://hl7.org/fhir/datatypes.html#CodeableConcept">CodeableConcept</a></li>
</ul>

<p>These types correspond directly to the CQL primitive types:</p>

<ul>
  <li><a href="https://cql.hl7.org/09-b-cqlreference.html#string-1">String</a></li>
  <li><a href="https://cql.hl7.org/09-b-cqlreference.html#code-1">Code</a></li>
  <li><a href="https://cql.hl7.org/09-b-cqlreference.html#concept-1">Concept</a></li>
</ul>

<p>In addition to the type of element, FHIR provides the ability to bind these elements to specific codes, in the form of a direct-reference code (constraint to a specific code in a <a href="http://hl7.org/fhir/codesystem.html">CodeSystem</a>), or a binding to a <a href="http://hl7.org/fhir/valueset.html">ValueSet</a>. These bindings can be different <a href="http://hl7.org/fhir/codesystem-binding-strength.html">binding strengths</a>:</p>

<ul>
  <li><a href="http://hl7.org/fhir/terminologies.html#required">required</a> - To be conformant, the concept in this element SHALL be from the specified value set.</li>
  <li><a href="http://hl7.org/fhir/terminologies.html#extensible">extensible</a> - To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated. If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead.</li>
  <li><a href="http://hl7.org/fhir/terminologies.html#preferred">preferred</a> - Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant.</li>
  <li><a href="http://hl7.org/fhir/terminologies.html#example">example</a> - Instances are not expected or even encouraged to draw from the specified value set. The value set merely provides examples of the types of concepts intended to be included.</li>
</ul>

<p>Within CQL, references to terminology code systems, value sets, codes, and concepts are directly supported, and all such usages are declared within CQL libraries, as described in the <a href="https://cql.hl7.org/02-authorsguide.html#terminology">Terminology</a> section of the CQL Author’s Guide.</p>

<p>When referencing terminology-valued elements within CQL, the following comparison operations are supported:</p>

<ul>
  <li><a href="https://cql.hl7.org/09-b-cqlreference.html#equal-3">Equal (<code class="highlighter-rouge">=</code>)</a></li>
  <li><a href="https://cql.hl7.org/09-b-cqlreference.html#equivalent-3">Equivalent (<code class="highlighter-rouge">~</code>)</a></li>
  <li><a href="https://cql.hl7.org/09-b-cqlreference.html#in-valueset">In (<code class="highlighter-rouge">in</code>)</a></li>
</ul>

<h3 id="translation-to-elm">Translation to ELM</h3>

<p>Note: For an introduction to ELM, see <a href="https://cql.hl7.org/04-logicalspecification.html">Chapter 4 - Logical Specification</a> of the CQL Specification.</p>

<p>Tooling exists to support translation of CQL to ELM for distribution in XML or JSON formats. These distributions SHOULD be included with computable artifacts to facilitate implementation. The existing translator tooling applies to both measure and decision support development, and has several options available to make use of different data models in different environments. For computable guideline content development with FHIR, the following options are recommended:</p>

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Description</th>
      <th>Recommendation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>EnableAnnotations</td>
      <td>This instructs the translator to include the source CQL as an annotation within the ELM.</td>
      <td>This option SHOULD be used to ensure that the distributed ELM could be linked back to the source CQL.</td>
    </tr>
    <tr>
      <td>EnableLocators</td>
      <td>This instructs the translator to include line number and character information for each ELM node.</td>
      <td>This option SHOULD be used to ensure that distributed ELM could be tied directly to the input source CQL.</td>
    </tr>
    <tr>
      <td>DisableListDemotion</td>
      <td>This instructs the translator to disallow demotion of list-valued expressions to singletons. The list demotion feature of CQL is used to enable functionality related to use with FHIRPath.</td>
      <td>This option SHOULD be used with quality improvement artifacts to ensure list demotion does not occur unexpectedly.</td>
    </tr>
    <tr>
      <td>DisableListPromotion</td>
      <td>This instructs the translator to disallow promotion of singletons to list-valued expressions. The list promotion feature of CQL is used to enable functionality related to use with FHIRPath.</td>
      <td>This option SHOULD be used with quality improvement artifacts to ensure list promotion does not occur unexpectedly.</td>
    </tr>
    <tr>
      <td>DisableMethodInvocation</td>
      <td>This instructs the translator to disallow method-style invocation. The method-style invocation feature of CQL is used to enable functionality related to use with FHIRPath.</td>
      <td>This option SHOULD be used with quality improvement artifacts to ensure method-style invocation cannot be used within eCQMs.</td>
    </tr>
    <tr>
      <td>EnableDateRangeOptimization</td>
      <td>This instructs the translator to optimize date range filters by moving them inside retrieve expressions.</td>
      <td>This feature MAY be used with quality improvement artifacts.</td>
    </tr>
    <tr>
      <td>EnableResultTypes</td>
      <td>This instructs the translator to include inferred result types in the output ELM.</td>
      <td>This feature MAY be used with quality improvement artifacts.</td>
    </tr>
    <tr>
      <td>EnableDetailedErrors</td>
      <td>This instructs the translator to include detailed error information. By default, the translator only reports root-cause errors.</td>
      <td>This feature SHOULD NOT be used with quality improvement artifacts.</td>
    </tr>
    <tr>
      <td>DisableListTraversal</td>
      <td>This instructs the translator to disallow traversal of list-valued expressions. With quality improvement artifacts, disabling this feature would prevent a useful capability.</td>
      <td>This feature SHOULD NOT be used with quality improvement artifacts.</td>
    </tr>
  </tbody>
</table>

<!-- ==============END CONTENT END CONTENT=================== -->

{% include container-end.html %}

{% include footer.html %}
